#!/usr/bin/env bash
#
# dsync - Distributed Development Sync Tool
# Seamlessly sync project files across your development machines
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_FILE="${HOME}/.config/dsync/config.yaml"

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Default configuration
DEFAULT_SYNC_DIRS=(
    "${HOME}/distributed"
    "${HOME}/charmtuitemplate"
    "${HOME}/projects"
)

usage() {
    cat <<EOF
dsync - Distributed Development Sync

USAGE:
    dsync <command> [options]

COMMANDS:
    push <path>         Push directory to all dev machines
    pull <host> <path>  Pull directory from specific machine
    sync <path>         Bidirectional sync (push to all)
    status              Show sync status across machines
    watch <path>        Watch directory and auto-sync on changes

OPTIONS:
    -g, --group <name>  Target specific group (default: dev)
    -h, --host <name>   Target specific host only
    -d, --dry-run       Show what would be synced
    -v, --verbose       Verbose output
    -x, --exclude       Patterns to exclude (can specify multiple)

EXAMPLES:
    # Push current directory to all dev machines
    dsync push .

    # Push specific directory to high-compute group
    dsync push ~/projects/myapp -g high-compute

    # Pull from homelab
    dsync pull homelab ~/projects/myapp

    # Check sync status
    dsync status

    # Dry run to see what would sync
    dsync push . --dry-run

    # Watch directory for changes and auto-sync
    dsync watch ~/projects/myapp

EOF
}

error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

info() {
    echo -e "${BLUE}ℹ $1${NC}"
}

success() {
    echo -e "${GREEN}✓ $1${NC}"
}

warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

# Get absolute path
get_abs_path() {
    local path="$1"
    if [[ "$path" == "." ]]; then
        pwd
    elif [[ "$path" == /* ]]; then
        echo "$path"
    else
        echo "$(pwd)/$path"
    fi
}

# Get relative path from HOME for remote sync
get_remote_path() {
    local abs_path="$1"
    echo "${abs_path/#$HOME/\~}"
}

# Push files to machines
cmd_push() {
    local source_path="$1"
    local group="${GROUP:-dev}"
    local host="${HOST:-}"
    local dry_run="${DRY_RUN:-false}"

    local abs_path
    abs_path="$(get_abs_path "$source_path")"

    if [[ ! -d "$abs_path" && ! -f "$abs_path" ]]; then
        error "Path does not exist: $abs_path"
    fi

    info "Syncing: $abs_path"

    if [[ -n "$host" ]]; then
        info "Target host: $host"
    else
        info "Target group: $group"
    fi

    local remote_path
    remote_path="$(get_remote_path "$abs_path")"

    local excludes=(
        "--exclude=.git"
        "--exclude=node_modules"
        "--exclude=.DS_Store"
        "--exclude=*.pyc"
        "--exclude=__pycache__"
        "--exclude=.venv"
        "--exclude=venv"
        "--exclude=dist"
        "--exclude=build"
        "--exclude=.next"
    )

    if [[ "$dry_run" == "true" ]]; then
        info "DRY RUN - No files will be transferred"
        if [[ -n "$host" ]]; then
            sshsync push --host "$host" "$abs_path" "$remote_path" --dry-run --recurse
        else
            sshsync push --group "$group" "$abs_path" "$remote_path" --dry-run --recurse
        fi
    else
        info "Starting sync..."
        if [[ -n "$host" ]]; then
            sshsync push --host "$host" "$abs_path" "$remote_path" --recurse
        else
            sshsync push --group "$group" "$abs_path" "$remote_path" --recurse
        fi
        success "Sync complete!"
    fi
}

# Pull files from a specific machine
cmd_pull() {
    local host="$1"
    local remote_path="$2"
    local local_path="${3:-.}"

    info "Pulling from: $host"
    info "Remote path: $remote_path"
    info "Local path: $local_path"

    sshsync pull --host "$host" "$remote_path" "$local_path" --recurse
    success "Pull complete!"
}

# Show sync status
cmd_status() {
    info "Checking status of development machines..."
    echo ""
    sshsync ls
    echo ""
    info "Testing connectivity..."
    sshsync group dev "echo 'OK: \$(hostname)'" 2>/dev/null || warning "Some machines may be offline"
}

# Watch directory for changes and auto-sync
cmd_watch() {
    local path="$1"
    local abs_path
    abs_path="$(get_abs_path "$path")"

    if [[ ! -d "$abs_path" ]]; then
        error "Directory does not exist: $abs_path"
    fi

    info "Watching: $abs_path"
    info "Press Ctrl+C to stop"
    echo ""

    # Check if fswatch is available
    if command -v fswatch &> /dev/null; then
        fswatch -o "$abs_path" | while read -r; do
            echo -e "${BLUE}$(date '+%H:%M:%S')${NC} Change detected, syncing..."
            cmd_push "$abs_path" &
        done
    else
        warning "fswatch not installed. Install with: brew install fswatch"
        info "Falling back to manual sync every 10 seconds..."
        while true; do
            cmd_push "$abs_path"
            sleep 10
        done
    fi
}

# Parse arguments
GROUP=""
HOST=""
DRY_RUN="false"
VERBOSE="false"

if [[ $# -eq 0 ]]; then
    usage
    exit 0
fi

COMMAND="$1"
shift

while [[ $# -gt 0 ]]; do
    case $1 in
        -g|--group)
            GROUP="$2"
            shift 2
            ;;
        --host)
            HOST="$2"
            shift 2
            ;;
        -d|--dry-run)
            DRY_RUN="true"
            shift
            ;;
        -v|--verbose)
            VERBOSE="true"
            shift
            ;;
        --help)
            usage
            exit 0
            ;;
        *)
            ARGS+=("$1")
            shift
            ;;
    esac
done

# Execute command
case "$COMMAND" in
    push)
        cmd_push "${ARGS[0]:-.}"
        ;;
    pull)
        cmd_pull "${ARGS[0]}" "${ARGS[1]}" "${ARGS[2]:-}"
        ;;
    sync)
        cmd_push "${ARGS[0]:-.}"
        ;;
    status)
        cmd_status
        ;;
    watch)
        cmd_watch "${ARGS[0]:-.}"
        ;;
    *)
        echo "Unknown command: $COMMAND"
        usage
        exit 1
        ;;
esac
